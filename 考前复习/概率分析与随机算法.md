# 概率分析与随机算法

>假设有$10$张牌，每张牌上分别标有从$10$的数字，且每张牌上的数字均不同，将牌
>充分混合。然后从牌堆中一次一张地移除三张牌。那么我们选出的三张牌按照（递增）顺
>序排列的概率是多少？

抽三张牌可能的排列总数为$10 \times 9 \times 8 = 720$，
而抽三张牌的组合数为$\dbinom{10}{3} = 120$，其中一个组合对应多种排列，有且仅有一种排列
是递增的，因此三张牌的组合数就是抽三张牌为递增的事件数量。

综上所诉，概率为$P = 120/720 = 1/6$。

[参考链接](https://math.stackexchange.com/questions/648551/probability-problem-shuffling-cards)

>你参加一个游戏。该游戏将奖品藏在了三个幕布之后。如果你选对了幕布，则可以赢得
>奖品。在你选择了一个幕布后，但是幕布还未揭开之前，主持人会揭开另两个幕布中一
>个空幕布（主持人知道哪个幕布后是空的），之后会询问你要不要改变你的选择。请间如
>果你改变了选择，那么你赢得奖品的几率将如何改变？（这一问题是著名的 Monty hall
>题，是以一个主持人经常让参赛者陷入这种困境的节目命名的。）

三门问题，个人的理解：
一开始在A、B和C的概率分别是$1/3$，在选择A后，奖品在B和C（不在A中）中的概率为$2/3$。

这时候，主持人确定奖品不在B中，所以此时奖品不在A中的概率就等同于在C中的概率$2/3$。
可以粗略的说，原本在B的概率流向了C中。

>一个监狱看守从三个罪犯中随机挑选一个释放，并处死另两人。这个看守知道每个人会
>被释放还是处死，但是被禁止透漏给囚犯其自身的处置信息。称罪犯为X、Y和Z。罪
>X以他已经知道了中至少有一人会死为理由，私下问警卫两人中哪个会被处
>死。警卫不能透露给关于他自身的信息，但他告诉了X, Y将被处死。 感到很开
>心，因为他认为他或者将被释放，这意味着他被释放的概率现在是1/2了。请问他的
>想法正确吗，或者他被释放的概率仍为1/3? 请解释。

一共有三种情况，XY被处死，YZ被处死，XZ被处死。
如果是XY这种情况，看守只能告诉X是Y将被处死（被禁止透漏给囚犯其自身的处置信息）。

设事件B是得知Y将被处死，事件$A_1$是XY被处死，事件$A_2$是X被释放，Y被处死（即YZ被处死）。

因此有条件概率，

$$
P(B|A_1) = 1, \quad P(B|A_2) = 1/2
$$

因此，在得知Y将被处死的条件下，X存活（事件$A_2$）发生的概率可以由贝叶斯公式计算，

$$
\begin{aligned}
P(A_2|B) &= \frac{P(B|A_2) P(A_2)}{P(B|A_1) P(A_1) + P(B|A_2) P(A_2)} \\
&= \frac{1/2 \times 1/3}{1 \times 1/3 + 1/2 \times 1/3} \\
&= 1/3
\end{aligned}
$$

>在一场狂欢节游戏中，将3个骰子放在一个罩子中。一位游戏者可以在1到6中的任意数字
>上赌1美元。主持人摇罩子，并按如下方案确定游戏者所得回报。如果游戏者赌的数字没有
>出现在任何一个骰子上，则他输掉1美元。如果他赌的数字恰好出现在k个骰子上，
>k=l, 2, 3, 则他可以保留他的1美元，并赢得k美元。请计算玩这个游戏一次的期望收入。

| 美元 | 概率      |
| ---- | --------- |
| -1   | $125/215$ |
| 1    | $25/72$   |
| 2    | $5/72$    |
| 3    | $1/216$   |

以$k=2$为例，需要有选两个骰子与选择的点数相同，剩下一个还要与它不同。总的样本空间数就是
三个骰子组成的所有可能性。
$$
P = \frac{\dbinom{3}{2} \times 5}{6^3} = 5/72
$$

最后数学期望为$E(X) = - 0.08$。

## 拉斯维加斯（Las Vegas）算法

一旦用拉斯维加斯算法找到一个解，那么这个解肯定是正确的，但有时用拉斯维加斯算法可能找不到解。

例如：八皇后问题，每次随机分配八个皇后的位置，检查这个解是否成立，如果不成立则重新调用算法。

## 舍伍德（Sherwood）算法

总能求得问题的一个解，且求得的解总是正确的。

很多算法对于不同的输入实例，其运行时间差别很大。此时，可以采用舍伍德型概
率算法来消除算法的时间复杂性与输入实例间的这种联系。

例如：在快排前对数组进行一次随机打乱，防止初始序列使枢纽点的选择变成最差的情况。
把所有情况变成平均的情况。

>请描述`RANDOM(a, b)`过程的一种实现，它只调用`RANDOM(O, 1)`。作为a和b的函
>数，你的过程的期望运行时间是多少？

```Rust
// RANDOM
fn random(a: u32, b: u32) -> u32 {
    //returns a random integer number between a and b, includes a and b
    let (p, len, diff) = (1, 1, b - a);
    //Sift [a, b] to [0, b-a]
    //Generate a random number in [0, b-a] by bit
    while p < diff {
       p = p << 1;
       len += 1;
    }
    //Get smallest number p is greater than difference in the power of 2 format
    let rst;

    loop {
        rst = 0;

        for i in 1..=len {
            rst = (rst << 1) + RANDOM(0, 1);
        }

        if rst <= b {
            break;
        }
    }

    rst + a
}
```

这个算法可以看出有拉斯维加斯算法思想的，因为区间大小不一定为2的幂，因此我们是假设范围是
覆盖区间的最小2的幂，然后随机生成一个数，如果这个数不在结果区间内，那就重新跑一次算法（loop）。

>假设你希望以 1/2的概率输出 。你可以自由使用一个输出的过程 BIASED-RANDOM。它以某概率p
>输出 1, 概率1-p输出0, 其中 $O<p<1$, 但是p的值未知。
>请给出一个利用 BIASED-RANDOM 作为子程序的算法，返回一个无偏的结果，能以概率
>1/2返回0, 以概率1/2返回 。作为p的函数，你的算法的期望运行时间是多少？

还是拉斯维加斯算法的思想，构造概率相等的情况，BIASED-RANDOM生成1和0的概率分别为p和1-p，
那么生成10这个事件的概率就是p(1-p)，同理生成01的概率为(1-p)p，这两个不同的事件概率相等。

```rust
//UNBIASED-RANDOM
fn unbiased_ramdom() -> u32 {
    loop {
        let x = biased_random();
        let y = biased_random();
        if x != y {
            break x;
        }
    }
}
```

>在HIRE-ASSISTANT 中，假设应聘者以随机顺序出现，你正好雇用一次的概率是多少？
>正好雇用n次的概率是多少？

应聘者的**质量**（优秀程度）可以看作<1, 2, 3, ..., n>的一个排列，
正好雇用一次是因为最优秀的应聘者在1号位置；
正好雇用n次是应聘者质量递增。

因此概率分别为，
$$
P_1 = \frac{(n-1)!}{n!} = 1/n \quad P_2 = \frac{1}{n!}
$$

>在HIRE-ASSISTANT 中，假设应聘者以随机顺序出现，你正好雇用两次的概率是多少？

可以第一个人隐藏后面的人，直到最优秀的应聘者出现。

$E_i$是第1个面聘者是第i优秀，显然$P(E_i) = 1/n$。
$F$是事件第2个到第j-1应聘者不如第1位应聘者。$F|e_i$前i人的顺序只要保证第一个人是i，后
n-i名候选者需要第一个人是最优秀的。
$$P(F|E_i) = \frac{(i-1)!(n-i-1)!}{(i-1)!(n-i)!} = 1/(n-i)$$

只雇用两次事件$A = F \cap (E_1 \cup E_2 \cup \cdots \cup E_n)$，

进而概率，
$$
\begin{aligned}
   P(A) =& \sum_{i=1}^{n-1} P(F \cap E_i) \\
   =&  \sum_{i=1}^{n-1} P(F | E_i) P(E_i) \\
   =& \frac{1}{n} \sum_{i=1}^{n-1} \frac{1}{n-i}
\end{aligned}
$$

错误想法

~~第二个人最优秀，其余人随意排列，概率仍旧为$1/n$。~~

>Armstrong 教授建议用下面的过程来产生一个均匀随机排列：
>
>```pseu
>PER TE-BY-CYCLIC(A)
>1 n = A. length 
>2 let B[l. . n] be a new array 
>3 offset= RANOOM(l, n) 
>4 for i = 1 to n 
>5     dest = i + offset 
>6     if dest > n 
>7         dest = dest - n 
>8         B[dest] = A[i] 
>9 return B 
>```
>
>请说明每个元素 A[i]出现在B中任何特定位置的概率是 1/n 。然后通过说明排列结果不
>是均匀随机排列，表明 Armstrong 教授错了。

每个元素A[i]将会放到B数组中的dest位置，dest是1到n等可能的；但每个元素任意位置是等可能的，
并不代表总体排列是均匀的，因为dest可能会发生冲突。
